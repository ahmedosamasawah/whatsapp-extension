var options = (function () {
	'use strict';

	const node_env = globalThis.process?.env?.NODE_ENV;
	var DEV = node_env && !node_env.toLowerCase().startsWith('prod');

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;
	var is_extensible = Object.isExtensible;

	const noop = () => {};

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	const INSPECT_EFFECT = 1 << 18;
	const HEAD_EFFECT = 1 << 19;
	const EFFECT_HAS_DERIVED = 1 << 20;
	const EFFECT_IS_UPDATING = 1 << 21;

	const STATE_SYMBOL = Symbol('$state');
	const LOADING_ATTR_SYMBOL = Symbol('');

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead
	 * @returns {never}
	 */
	function bind_invalid_checkbox_value() {
		if (DEV) {
			const error = new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		if (DEV) {
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/derived_references_self`);
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		if (DEV) {
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		if (DEV) {
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		if (DEV) {
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		if (DEV) {
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		if (DEV) {
			const error = new Error(`state_unsafe_mutation\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';
			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_HTML = 'http://www.w3.org/1999/xhtml';

	/** @import { Derived, Reaction, Value } from '#client' */

	/** @type { any } */
	let tracing_expressions = null;

	/**
	 * @param {string} label
	 */
	function get_stack(label) {
		let error = Error();
		const stack = error.stack;

		if (stack) {
			const lines = stack.split('\n');
			const new_lines = ['\n'];

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];

				if (line === 'Error') {
					continue;
				}
				if (line.includes('validate_each_keys')) {
					return null;
				}
				if (line.includes('svelte/src/internal')) {
					continue;
				}
				new_lines.push(line);
			}

			if (new_lines.length === 1) {
				return null;
			}

			define_property(error, 'stack', {
				value: new_lines.join('\n')
			});

			define_property(error, 'name', {
				// 'Error' suffix is required for stack traces to be rendered properly
				value: `${label}Error`
			});
		}
		return error;
	}

	/** @import { ComponentContext } from '#client' */


	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		var ctx = (component_context = {
			p: component_context,
			c: null,
			d: false,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		});

		teardown(() => {
			/** @type {ComponentContext} */ (ctx).d = true;
		});

		if (DEV) {
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			if (DEV) {
				dev_current_component_function = context_stack_item.p?.function ?? null;
			}
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag ;
	}

	/** @import { Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);

		var stack = DEV && tracing_mode_flag ? get_stack('CreatedAt') : null;
		var reaction = active_reaction;

		/**
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			var previous_reaction = active_reaction;
			set_active_reaction(reaction);

			/** @type {T} */
			var result = fn();

			set_active_reaction(previous_reaction);
			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length, stack));
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}

				var s = sources.get(prop);

				if (s === undefined) {
					s = with_parent(() => state(descriptor.value, stack));
					sources.set(prop, s);
				} else {
					set$2(
						s,
						with_parent(() => proxy(descriptor.value))
					);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						sources.set(
							prop,
							with_parent(() => state(UNINITIALIZED, stack))
						);
						update_version(version);
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set$2(ls, n);
						}
					}
					set$2(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => state(proxy(exists ? target[prop] : UNINITIALIZED), stack));
					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get$3(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get$3(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => state(has ? proxy(target[prop]) : UNINITIALIZED, stack));
						sources.set(prop, s);
					}

					var value = get$3(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set$2(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED, stack));
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined, stack));
						set$2(
							s,
							with_parent(() => proxy(value))
						);
						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;
					set$2(
						s,
						with_parent(() => proxy(value))
					);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set$2(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get$3(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set$2(signal, signal.v + d);
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		try {
			if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
				return value[STATE_SYMBOL];
			}
		} catch {
			// the above if check can throw an error if the value in question
			// is the contentWindow of an iframe on another domain, in which
			// case we want to just return the value (because it's definitely
			// not a proxied value) so we don't break any JavaScript interacting
			// with that iframe (such as various payment companies client side
			// JavaScript libraries interacting with their iframes on the same
			// domain)
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived$1(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (null),
			wv: 0,
			parent: parent_derived ?? active_effect
		};

		if (DEV && tracing_mode_flag) {
			signal.created = get_stack('CreatedAt');
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived$1(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		if (DEV) {
			let prev_inspect_effects = inspect_effects;
			set_inspect_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_inspect_effects(prev_inspect_effects);
				stack.pop();
			}
		} else {
			try {
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);
		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	let inspect_effects = new Set();
	const old_values = new Map();

	/**
	 * @param {Set<any>} v
	 */
	function set_inspect_effects(v) {
		inspect_effects = v;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		if (DEV && tracing_mode_flag) {
			signal.created = stack ?? get_stack('CreatedAt');
			signal.debug = null;
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v, stack);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set$2(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			!untracking &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			!reaction_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			if (DEV && tracing_mode_flag) {
				source.updated = get_stack('UpdatedAt');
				if (active_effect != null) {
					source.trace_need_increase = true;
					source.trace_v ??= old_value;
				}
			}

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (DEV && inspect_effects.size > 0) {
				const inspects = Array.from(inspect_effects);

				for (const effect of inspects) {
					// Mark clean inspect-effects as maybe dirty and then check their dirtiness
					// instead of just updating the effects - this way we avoid overfiring.
					if ((effect.f & CLEAN) !== 0) {
						set_signal_status(effect, MAYBE_DIRTY);
					}
					if (check_dirtiness(effect)) {
						update_effect(effect);
					}
				}

				inspect_effects.clear();
			}
		}

		return value;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if (DEV && (flags & INSPECT_EFFECT) !== 0) {
				inspect_effects.add(reaction);
				continue;
			}

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		if (DEV) {
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	function init_array_prototype_warnings() {
		const array_prototype = Array.prototype;
		// The REPL ends up here over and over, and this prevents it from adding more and more patches
		// of the same kind to the prototype, which would slow down everything over time.
		// @ts-expect-error
		const cleanup = Array.__svelte_cleanup;
		if (cleanup) {
			cleanup();
		}

		const { indexOf, lastIndexOf, includes } = array_prototype;

		array_prototype.indexOf = function (item, from_index) {
			const index = indexOf.call(this, item, from_index);

			if (index === -1) {
				for (let i = from_index ?? 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.indexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.lastIndexOf = function (item, from_index) {
			// we need to specify this.length - 1 because it's probably using something like
			// `arguments` inside so passing undefined is different from not passing anything
			const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);

			if (index === -1) {
				for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.lastIndexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.includes = function (item, from_index) {
			const has = includes.call(this, item, from_index);

			if (!has) {
				for (let i = 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.includes(...)');
						break;
					}
				}
			}

			return has;
		};

		// @ts-expect-error
		Array.__svelte_cleanup = () => {
			array_prototype.indexOf = indexOf;
			array_prototype.lastIndexOf = lastIndexOf;
			array_prototype.includes = includes;
		};
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;
		var text_prototype = Text.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		if (is_extensible(element_prototype)) {
			// the following assignments improve perf of lookups on DOM nodes
			// @ts-expect-error
			element_prototype.__click = undefined;
			// @ts-expect-error
			element_prototype.__className = undefined;
			// @ts-expect-error
			element_prototype.__attributes = null;
			// @ts-expect-error
			element_prototype.__style = undefined;
			// @ts-expect-error
			element_prototype.__e = undefined;
		}

		if (is_extensible(text_prototype)) {
			// @ts-expect-error
			text_prototype.__t = undefined;
		}

		if (DEV) {
			// @ts-expect-error
			element_prototype.__svelte_meta = null;

			init_array_prototype_warnings();
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		if (DEV) {
			// Ensure the parent is never an inspect effect
			while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
				parent = parent.parent;
			}
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0
		};

		if (DEV) {
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;

		if (!inert && push) {
			if (parent !== null) {
				push_effect(effect, parent);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.effects ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} thunks
	 * @returns {Effect}
	 */
	function template_effect(fn, thunks = [], d = derived$1) {
		const deriveds = thunks.map(d);
		const effect = () => fn(...deriveds.map(get$3));

		if (DEV) {
			define_property(effect, 'name', {
				value: '{expression}'
			});
		}

		return block(effect);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		if (DEV) {
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// Ensure the effect is marked as clean again so that any dirty child
		// effects can schedule themselves for execution
		if ((effect.f & CLEAN) === 0) {
			effect.f ^= CLEAN;
		}

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update
		if (check_dirtiness(effect)) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0) {
			queueMicrotask(run_micro_tasks);
		}

		micro_tasks.push(fn);
	}

	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	// Used for DEV time error handling
	/** @param {WeakSet<Error>} value */
	const handled_errors = new WeakSet();
	let is_throwing_error = false;

	let is_flushing = false;

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_updating_effect = false;

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them should not cause a re-run
	 * @type {null | Source[]}
	 */
	let reaction_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && active_reaction.f & EFFECT_IS_UPDATING) {
			if (reaction_sources === null) {
				reaction_sources = [value];
			} else {
				reaction_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency
				if (is_disconnected || is_unowned_connected) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 */
	function propagate_error(error, effect) {
		/** @type {Effect | null} */
		var current = effect;

		while (current !== null) {
			if ((current.f & BOUNDARY_EFFECT) !== 0) {
				try {
					// @ts-expect-error
					current.fn(error);
					return;
				} catch {
					// Remove boundary flag from effect
					current.f ^= BOUNDARY_EFFECT;
				}
			}

			current = current.parent;
		}

		is_throwing_error = false;
		throw error;
	}

	/**
	 * @param {Effect} effect
	 */
	function should_rethrow_error(effect) {
		return (
			(effect.f & DESTROYED) === 0 &&
			(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)
		);
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 * @param {Effect | null} previous_effect
	 * @param {ComponentContext | null} component_context
	 */
	function handle_error(error, effect, previous_effect, component_context) {
		if (is_throwing_error) {
			if (previous_effect === null) {
				is_throwing_error = false;
			}

			if (should_rethrow_error(effect)) {
				throw error;
			}

			return;
		}

		if (previous_effect !== null) {
			is_throwing_error = true;
		}

		if (DEV && component_context !== null && error instanceof Error && !handled_errors.has(error)) {
			handled_errors.add(error);

			const component_stack = [];

			const effect_name = effect.fn?.name;

			if (effect_name) {
				component_stack.push(effect_name);
			}

			/** @type {ComponentContext | null} */
			let current_context = component_context;

			while (current_context !== null) {
				/** @type {string} */
				var filename = current_context.function?.[FILENAME];

				if (filename) {
					const file = filename.split('/').pop();
					component_stack.push(file);
				}

				current_context = current_context.p;
			}

			const indent = is_firefox ? '  ' : '\t';
			define_property(error, 'message', {
				value:
					error.message + `\n${component_stack.map((name) => `\n${indent}in ${name}`).join('')}\n`
			});
			define_property(error, 'component_stack', {
				value: component_stack
			});

			const stack = error.stack;

			// Filter out internal files from callstack
			if (stack) {
				const lines = stack.split('\n');
				const new_lines = [];
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i];
					if (line.includes('svelte/src/internal')) {
						continue;
					}
					new_lines.push(line);
				}
				define_property(error, 'stack', {
					value: new_lines.join('\n')
				});
			}
		}

		propagate_error(error, effect);

		if (should_rethrow_error(effect)) {
			throw error;
		}
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if (reaction_sources?.includes(signal)) continue;

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/**
	 * @template V
	 * @param {Reaction} reaction
	 * @returns {V}
	 */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_reaction_sources = reaction_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		reaction_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		read_version++;

		reaction.f |= EFFECT_IS_UPDATING;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			return result;
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			reaction_sources = previous_reaction_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;

			reaction.f ^= EFFECT_IS_UPDATING;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var previous_component_context = component_context;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		if (DEV) {
			var previous_component_fn = dev_current_component_function;
			set_dev_current_component_function(effect.component_function);
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			var deps = effect.deps;

			// In DEV, we need to handle a case where $inspect.trace() might
			// incorrectly state a source dependency has not changed when it has.
			// That's beacuse that source was changed by the same effect, causing
			// the versions to match. We can avoid this by incrementing the version
			if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && deps !== null) {
				for (let i = 0; i < deps.length; i++) {
					var dep = deps[i];
					if (dep.trace_need_increase) {
						dep.wv = increment_write_version();
						dep.trace_need_increase = undefined;
						dep.trace_v = undefined;
					}
				}
			}

			if (DEV) {
				dev_effect_stack.push(effect);
			}
		} catch (error) {
			handle_error(error, effect, previous_effect, previous_component_context || effect.ctx);
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;

			if (DEV) {
				set_dev_current_component_function(previous_component_fn);
			}
		}
	}

	function log_effect_stack() {
		// eslint-disable-next-line no-console
		console.error(
			'Last ten effects were: ',
			dev_effect_stack.slice(-10).map((d) => d.fn)
		);
		dev_effect_stack = [];
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {
			if (DEV) {
				// stack is garbage, ignore. Instead add a console.error message.
				define_property(error, 'stack', {
					value: ''
				});
			}
			// Try and handle the error so it can be caught at a boundary, that's
			// if there's an effect available from when it was last scheduled
			if (last_scheduled_effect !== null) {
				if (DEV) {
					try {
						handle_error(error, last_scheduled_effect, null, null);
					} catch (e) {
						// Only log the effect stack if the error is re-thrown
						log_effect_stack();
						throw e;
					}
				} else {
					handle_error(error, last_scheduled_effect, null, null);
				}
			} else {
				if (DEV) {
					log_effect_stack();
				}
				throw error;
			}
		}
	}

	function flush_queued_root_effects() {
		var was_updating_effect = is_updating_effect;

		try {
			var flush_count = 0;
			is_updating_effect = true;

			while (queued_root_effects.length > 0) {
				if (flush_count++ > 1000) {
					infinite_loop_guard();
				}

				var root_effects = queued_root_effects;
				var length = root_effects.length;

				queued_root_effects = [];

				for (var i = 0; i < length; i++) {
					var collected_effects = process_effects(root_effects[i]);
					flush_queued_effects(collected_effects);
				}
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			is_updating_effect = was_updating_effect;

			last_scheduled_effect = null;
			if (DEV) {
				dev_effect_stack = [];
			}
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0) {
				try {
					if (check_dirtiness(effect)) {
						update_effect(effect);

						// Effects with no dependencies or teardown do not get added to the effect tree.
						// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
						// don't know if we need to keep them until they are executed. Doing the check
						// here (rather than in `update_effect`) allows us to skip the work for
						// immediate effects.
						if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
							if (effect.teardown === null) {
								// remove this effect from the graph
								unlink_effect(effect);
							} else {
								// keep the effect in the graph, but free up some memory
								effect.fn = null;
							}
						}
					}
				} catch (error) {
					handle_error(error, effect, null, effect.ctx);
				}
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		if (!is_flushing) {
			is_flushing = true;
			queueMicrotask(flush_queued_root_effects);
		}

		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} root
	 * @returns {Effect[]}
	 */
	function process_effects(root) {
		/** @type {Effect[]} */
		var effects = [];

		/** @type {Effect | null} */
		var effect = root;

		while (effect !== null) {
			var flags = effect.f;
			var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & EFFECT) !== 0) {
					effects.push(effect);
				} else if (is_branch) {
					effect.f ^= CLEAN;
				} else {
					try {
						if (check_dirtiness(effect)) {
							update_effect(effect);
						}
					} catch (error) {
						handle_error(error, effect, null, effect.ctx);
					}
				}

				/** @type {Effect | null} */
				var child = effect.first;

				if (child !== null) {
					effect = child;
					continue;
				}
			}

			var parent = effect.parent;
			effect = effect.next;

			while (effect === null && parent !== null) {
				effect = parent.next;
				parent = parent.parent;
			}
		}

		return effects;
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get$3(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			if (!reaction_sources?.includes(signal)) {
				var deps = active_reaction.deps;
				if (signal.rv < read_version) {
					signal.rv = read_version;
					// If the signal is accessing the same dependencies in the same
					// order as it did last time, increment `skipped_deps`
					// rather than updating `new_deps`, which creates GC cost
					if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
						skipped_deps++;
					} else if (new_deps === null) {
						new_deps = [signal];
					} else if (!skip_reaction || !new_deps.includes(signal)) {
						// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
						// an unowned derived because skip_reaction is true, then we need to ensure that
						// we don't have duplicates
						new_deps.push(signal);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		if (
			DEV &&
			tracing_mode_flag &&
			tracing_expressions !== null &&
			active_reaction !== null &&
			tracing_expressions.reaction === active_reaction
		) {
			// Used when mapping state between special blocks like `each`
			if (signal.debug) {
				signal.debug();
			} else if (signal.created) {
				var entry = tracing_expressions.entries.get(signal);

				if (entry === undefined) {
					entry = { read: [] };
					tracing_expressions.entries.set(signal, entry);
				}

				entry.read.push(get_stack('TracedAt'));
			}
		}

		if (is_destroying_effect && old_values.has(signal)) {
			return old_values.get(signal);
		}

		return signal.v;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html;
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function template(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn
	 * @param {[number,number]} [elseif]
	 * @returns {void}
	 */
	function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (
			/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,
			flag = true
		) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else if (fn) {
					consequent_effect = branch(() => fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (fn) {
					alternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 * @param {Map<any, EachItem>} items_map
	 */
	function pause_effects(state, items, controlled_anchor, items_map) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = parent_node.appendChild(create_text());
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		block(() => {
			var array = get$3(each_array);
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			{
				reconcile(array, state, anchor, render_fn, flags, get_key, get_collection);
			}

			if (fallback_fn !== null) {
				if (length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get$3(each_array);
		});
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);
			item = items.get(key);

			if (item === undefined) {
				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

				prev = create_item(
					child_anchor,
					state,
					prev,
					prev === null ? state.first : prev.next,
					value,
					key,
					i,
					render_fn,
					flags,
					get_collection
				);

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor, items);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
		/** @type {Effect} */ (active_effect).last = prev && prev.e;
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection
	) {
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (DEV && reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).debug = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		try {
			item.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				state.first = item;
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff'];

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		if (hash) {
			classname = classname ? classname + ' ' + hash : hash;
		}

		if (directives) {
			for (var key in directives) {
				if (directives[key]) {
					classname = classname ? classname + ' ' + key : key;
				} else if (classname.length) {
					var len = key.length;
					var a = 0;

					while ((a = classname.indexOf(key, a)) >= 0) {
						var b = a + len;

						if (
							(a === 0 || whitespace.includes(classname[a - 1])) &&
							(b === classname.length || whitespace.includes(classname[b]))
						) {
							classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);
						} else {
							a = b;
						}
					}
				}
			}
		}

		return classname === '' ? null : classname;
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash, next_classes);

			{
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else if (is_html) {
					dom.className = next_class_name;
				} else {
					dom.setAttribute('class', next_class_name);
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		} else if (next_classes && prev_classes !== next_classes) {
			for (var key in next_classes) {
				var is_present = !!next_classes[key];

				if (prev_classes == null || is_present !== !!prev_classes[key]) {
					dom.classList.toggle(key, is_present);
				}
			}
		}

		return next_classes;
	}

	const IS_CUSTOM_ELEMENT = Symbol('is custom element');
	const IS_HTML = Symbol('is html');

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		var attributes = get_attributes(element);

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 *
	 * @param {Element} element
	 */
	function get_attributes(element) {
		return /** @type {Record<string | symbol, unknown>} **/ (
			// @ts-expect-error
			element.__attributes ??= {
				[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),
				[IS_HTML]: element.namespaceURI === NAMESPACE_HTML
			}
		);
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var setters = setters_cache.get(element.nodeName);
		if (setters) return setters;
		setters_cache.set(element.nodeName, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {

		listen_to_event_and_reset_event(input, 'input', (is_reset) => {
			if (DEV && input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,
			// because we use mutable state which ensures the render effect always runs)
			if (value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);
		}

		render_effect(() => {
			if (DEV && input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			var value = get();

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} [mounting]
	 */
	function select_option(select, value, mounting) {
		if (select.multiple) {
			return select_options(select, value);
		}

		for (var option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {() => V} [get_value]
	 */
	function init_select(select, get_value) {
		let mounting = true;
		effect(() => {
			if (get_value) {
				select_option(select, untrack(get_value), mounting);
			}
			mounting = false;

			var observer = new MutationObserver(() => {
				// @ts-ignore
				var value = select.__value;
				select_option(select, value);
				// Deliberately don't update the potential binding value,
				// the model should be preserved unless explicitly changed
			});

			observer.observe(select, {
				// Listen to option element changes
				childList: true,
				subtree: true, // because of <optgroup>
				// Listen to option element value attribute changes
				// (doesn't get notified of select value changes,
				// because that property is not reflected as an attribute)
				attributes: true,
				attributeFilter: ['value']
			});

			return () => {
				observer.disconnect();
			};
		});
	}

	/**
	 * @param {HTMLSelectElement} select
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_select_value(select, get, set = get) {
		var mounting = true;

		listen_to_event_and_reset_event(select, 'change', (is_reset) => {
			var query = is_reset ? '[selected]' : ':checked';
			/** @type {unknown} */
			var value;

			if (select.multiple) {
				value = [].map.call(select.querySelectorAll(query), get_option_value);
			} else {
				/** @type {HTMLOptionElement | null} */
				var selected_option =
					select.querySelector(query) ??
					// will fall back to first non-disabled option if no option is selected
					select.querySelector('option:not([disabled])');
				value = selected_option && get_option_value(selected_option);
			}

			set(value);
		});

		// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated
		effect(() => {
			var value = get();
			select_option(select, value, mounting);

			// Mounting and value undefined -> take selection from dom
			if (mounting && value === undefined) {
				/** @type {HTMLOptionElement | null} */
				var selected_option = select.querySelector(':checked');
				if (selected_option !== null) {
					value = get_option_value(selected_option);
					set(value);
				}
			}

			// @ts-ignore
			select.__value = value;
			mounting = false;
		});

		// don't pass get_value, we already initialize it in the effect above
		init_select(select);
	}

	/**
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 */
	function select_options(select, value) {
		for (var option of select.options) {
			// @ts-ignore
			option.selected = ~value.indexOf(get_option_value(option));
		}
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			// @ts-expect-error
			if (invalidate) invalidate(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */
	/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Creates a `Readable` store that allows reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Readable<T>}
	 */
	function readable(value, start) {
		return {
			subscribe: writable(value, start).subscribe
		};
	}

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * @template {Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores
	 * @param {(values: StoresValues<S>, set: (value: T) => void, update: (fn: Updater<T>) => void) => Unsubscriber | void} fn
	 * @param {T} [initial_value]
	 * @returns {Readable<T>}
	 */
	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * @template {Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores
	 * @param {(values: StoresValues<S>) => T} fn
	 * @param {T} [initial_value]
	 * @returns {Readable<T>}
	 */
	/**
	 * @template {Stores} S
	 * @template T
	 * @param {S} stores
	 * @param {Function} fn
	 * @param {T} [initial_value]
	 * @returns {Readable<T>}
	 */
	function derived(stores, fn, initial_value) {
		const single = !Array.isArray(stores);
		/** @type {Array<Readable<any>>} */
		const stores_array = single ? [stores] : stores;
		if (!stores_array.every(Boolean)) {
			throw new Error('derived() expects stores as input, got a falsy value');
		}
		const auto = fn.length < 2;
		return readable(initial_value, (set, update) => {
			let started = false;
			/** @type {T[]} */
			const values = [];
			let pending = 0;
			let cleanup = noop;
			const sync = () => {
				if (pending) {
					return;
				}
				cleanup();
				const result = fn(single ? values[0] : values, set, update);
				if (auto) {
					set(result);
				} else {
					cleanup = typeof result === 'function' ? result : noop;
				}
			};
			const unsubscribers = stores_array.map((store, i) =>
				subscribe_to_store(
					store,
					(value) => {
						values[i] = value;
						pending &= ~(1 << i);
						if (started) {
							sync();
						}
					},
					() => {
						pending |= 1 << i;
					}
				)
			);
			started = true;
			sync();
			return function stop() {
				run_all(unsubscribers);
				cleanup();
				// We need to set this to false because callbacks can still happen despite having unsubscribed:
				// Callbacks might already be placed in the queue which doesn't know it should no longer
				// invoke this derived store.
				started = false;
			};
		});
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * @template T
	 * @param {Readable<T>} store
	 * @returns {T}
	 */
	function get$2(store) {
		let value;
		subscribe_to_store(store, (_) => (value = _))();
		// @ts-expect-error
		return value;
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	let IS_UNMOUNTED = Symbol();

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		// if the component that setup this is already unmounted we don't want to register a subscription
		if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set$2(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		// if the component that setup this stores is already unmounted the source will be out of sync
		// so we just use the `get` for the stores, less performant but it avoids to create a memory leak
		// and it will keep the value consistent
		if (store && IS_UNMOUNTED in stores) {
			return get$2(store);
		}

		return get$3(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {[StoreReferencesContainer, ()=>void]}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		function cleanup() {
			teardown(() => {
				for (var store_name in stores) {
					const ref = stores[store_name];
					ref.unsubscribe();
				}
				define_property(stores, IS_UNMOUNTED, {
					enumerable: false,
					value: true
				});
			});
		}

		return [stores, cleanup];
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	if (DEV) {
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	function promisifyRequest(request) {
	    return new Promise((resolve, reject) => {
	        // @ts-ignore - file size hacks
	        request.oncomplete = request.onsuccess = () => resolve(request.result);
	        // @ts-ignore - file size hacks
	        request.onabort = request.onerror = () => reject(request.error);
	    });
	}
	function createStore(dbName, storeName) {
	    const request = indexedDB.open(dbName);
	    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
	    const dbp = promisifyRequest(request);
	    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
	}
	let defaultGetStoreFunc;
	function defaultGetStore() {
	    if (!defaultGetStoreFunc) {
	        defaultGetStoreFunc = createStore('keyval-store', 'keyval');
	    }
	    return defaultGetStoreFunc;
	}
	/**
	 * Get a value by its key.
	 *
	 * @param key
	 * @param customStore Method to get a custom store. Use with caution (see the docs).
	 */
	function get$1(key, customStore = defaultGetStore()) {
	    return customStore('readonly', (store) => promisifyRequest(store.get(key)));
	}
	/**
	 * Set a value with a key.
	 *
	 * @param key
	 * @param value
	 * @param customStore Method to get a custom store. Use with caution (see the docs).
	 */
	function set$1(key, value, customStore = defaultGetStore()) {
	    return customStore('readwrite', (store) => {
	        store.put(value, key);
	        return promisifyRequest(store.transaction);
	    });
	}
	function eachCursor(store, callback) {
	    store.openCursor().onsuccess = function () {
	        if (!this.result)
	            return;
	        callback(this.result);
	        this.result.continue();
	    };
	    return promisifyRequest(store.transaction);
	}
	/**
	 * Get all entries in the store. Each entry is an array of `[key, value]`.
	 *
	 * @param customStore Method to get a custom store. Use with caution (see the docs).
	 */
	function entries(customStore = defaultGetStore()) {
	    return customStore('readonly', (store) => {
	        // Fast path for modern browsers
	        // (although, hopefully we'll get a simpler path some day)
	        if (store.getAll && store.getAllKeys) {
	            return Promise.all([
	                promisifyRequest(store.getAllKeys()),
	                promisifyRequest(store.getAll()),
	            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));
	        }
	        const items = [];
	        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));
	    });
	}

	/** @param {string} key @param {string} [storageType='local'] @returns {Promise<any>} */
	async function get(key, storageType = "local") {
	  if (storageType === "indexedDB") return await get$1(key);
	  else {
	    return new Promise((resolve) =>
	      chrome.storage[storageType].get([key], (result) =>
	        resolve(result[key] !== undefined ? result[key] : null)
	      )
	    );
	  }
	}

	/** @param {string} key @param {any} value @param {string|Array<string>} [storageType='local'] @returns {Promise<boolean>} */
	async function set(key, value, storageType = "local") {
	  const storageTypes = Array.isArray(storageType) ? storageType : [storageType];

	  const promises = storageTypes.map((type) => {
	    if (type === "indexedDB") return set$1(key, value);
	    else
	      return new Promise((resolve) => {
	        const data = {};
	        data[key] = value;
	        chrome.storage[type].set(data, () => {
	          const error = chrome.runtime.lastError;
	          resolve(!error);
	        });
	      });
	  });

	  await Promise.all(promises);
	  return true;
	}

	/** @param {string} [storageType='local'] @returns {Promise<Object>} */
	async function getAll(storageType = "local") {
	  if (storageType === "indexedDB") return await entries();
	  else
	    return new Promise((resolve) => {
	      chrome.storage[storageType].get(null, (items) => {
	        resolve(items || {});
	      });
	    });
	}

	/** @returns {Promise<Map<string, Object>>} */
	async function getTranscriptions() {
	  const storedData = (await get("wa-transcriptions", "indexedDB")) || {};
	  return new Map(Object.entries(storedData));
	}

	/** @param {Object} config @returns {Object} */
	function createBaseProvider(config = {}) {
	  return {
	    config,
	    verifyApiKey: async (apiKey) => {
	      throw new Error("Function 'verifyApiKey' must be implemented");
	    },

	    transcribeAudio: async (audioBlob, options = {}) => {
	      throw new Error("Function 'transcribeAudio' must be implemented");
	    },

	    processTranscription: async (transcription, options = {}) => {
	      throw new Error("Function 'processTranscription' must be implemented");
	    },
	  };
	}

	/** @param {string} template @param {Object} variables @returns {string} */
	function renderTemplate(template, variables = {}) {
	  return template.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
	    const trimmedKey = key.trim();
	    return variables[trimmedKey] !== undefined ? variables[trimmedKey] : match;
	  });
	}

	const defaultTemplates = {
	  openai: {
	    processing: `You are an AI assistant that processes WhatsApp voice message transcriptions. Process the following transcript following these exact instructions:

Your response MUST follow this exact format with FOUR sections separated by '----':
[original transcript] ---- [grammatically corrected version in {{language}}]\n[English translation] ---- [concise summary in English] ---- [natural reply in {{language}}]

Instructions for each section:
1. First section: Copy the original transcript exactly as provided.
2. Second section: Create a grammatically correct, polished version of the transcript in {{language}}. Remove filler words, false starts, and repetitions. Maintain the original meaning. Then, on the next line, provide the English translation.
3. Third section: Write a concise 1-2 sentence summary in English that captures the core message and key information from the transcript.
4. Fourth section: Suggest a natural, conversational reply in {{language}} that directly addresses the main points or questions from the message. The reply should sound like something a real person would say in a WhatsApp conversation (not formal or robotic).

Use ONLY '----' as separators with no additional text, headers, or explanations.

TRANSCRIPT:
{{transcription}}`,
	  },
	};

	/** @param {string} errorText @param {string} defaultMessage @returns {Object} */
	function parseOpenAIError(
	  errorText,
	  defaultMessage = "API request failed"
	) {
	  try {
	    const errorData = JSON.parse(errorText);

	    if (!errorData.error)
	      return {
	        message: defaultMessage,
	        type: "unknown",
	        userMessage:
	          "There was an error processing your request. Please try again.",
	      };

	    switch (errorData.error.type) {
	      case "insufficient_quota":
	        return {
	          message:
	            "Your OpenAI API key has reached its usage limit. Please check your billing details or use a different API key.",
	          type: "quota_exceeded",
	          userMessage:
	            "Your API key has reached its usage limit. Please check your OpenAI account billing details or update your API key.",
	        };

	      case "invalid_request_error":
	        return {
	          message: errorData.error.message || "Invalid request to the API",
	          type: "invalid_request",
	          userMessage:
	            "There was a problem with the request. Please check your settings.",
	        };

	      case "authentication_error":
	        return {
	          message: "Authentication failed. Please check your API key.",
	          type: "authentication",
	          userMessage:
	            "Your API key appears to be invalid. Please check your settings.",
	        };

	      default:
	        return {
	          message: errorData.error.message || defaultMessage,
	          type: errorData.error.type || "unknown",
	          userMessage:
	            "There was an error processing your request. Please try again.",
	        };
	    }
	  } catch (parseError) {
	    return {
	      message: errorText || defaultMessage,
	      type: "unknown",
	      userMessage:
	        "There was an error processing your request. Please try again.",
	    };
	  }
	}

	/** @param {Object} config @returns {Object} */
	function createOpenAIProvider(config = {}) {
	  const provider = {
	    ...createBaseProvider(config),
	    apiKey: config.apiKey,
	    apiUrl: "https://api.openai.com",
	    transcriptionModel: config.transcriptionModel || "whisper-1",
	    processingModel: config.processingModel || "gpt-4o",

	    verifyApiKey: async (apiKey) => {
	      if (!apiKey) return { valid: false, error: "API key is empty" };
	      if (!apiKey.startsWith("sk-"))
	        return { valid: false, error: "Invalid API key format" };

	      try {
	        const response = await fetch(`${provider.apiUrl}/v1/models`, {
	          method: "GET",
	          headers: {
	            Authorization: `Bearer ${apiKey}`,
	            "Content-Type": "application/json",
	          },
	        });

	        if (!response.ok) {
	          const errorText = await response.text();
	          const errorData = parseOpenAIError(errorText, "Invalid API key");

	          return {
	            valid: false,
	            error: errorData.message,
	          };
	        }

	        return { valid: true };
	      } catch (error) {
	        return { valid: false, error: error.message || "Network error" };
	      }
	    },

	    transcribeAudio: async (audioBlob, options = {}) => {
	      if (!provider.apiKey) throw new Error("API key not configured");

	      const formData = new FormData();
	      formData.append("model", provider.transcriptionModel);
	      formData.append(
	        "file",
	        new File([audioBlob], "audio.ogg", { type: audioBlob.type })
	      );

	      if (options.language && options.language !== "auto")
	        formData.append("language", options.language);

	      const response = await fetch(
	        `${provider.apiUrl}/v1/audio/transcriptions`,
	        {
	          method: "POST",
	          headers: {
	            Authorization: `Bearer ${provider.apiKey}`,
	          },
	          body: formData,
	        }
	      );

	      if (!response.ok) {
	        const errorText = await response.text();
	        const errorData = parseOpenAIError(errorText, "Transcription failed");
	        throw new Error(errorData.message);
	      }

	      const result = await response.json();
	      return result.text;
	    },

	    processTranscription: async (transcription, options = {}) => {
	      if (!provider.apiKey) throw new Error("API key not configured");

	      const promptTemplate =
	        options.promptTemplate || defaultTemplates.openai.processing;

	      const promptContent = renderTemplate(promptTemplate, {
	        transcription,
	        language: options.language || "auto",
	      });

	      const response = await fetch(`${provider.apiUrl}/v1/chat/completions`, {
	        method: "POST",
	        headers: {
	          "Content-Type": "application/json",
	          Authorization: `Bearer ${provider.apiKey}`,
	        },
	        body: JSON.stringify({
	          model: provider.processingModel,
	          messages: [
	            {
	              role: "user",
	              content: promptContent,
	            },
	          ],
	        }),
	      });

	      if (!response.ok) {
	        const errorText = await response.text();
	        const errorData = parseOpenAIError(errorText, "Processing failed");
	        throw new Error(errorData.message);
	      }

	      const result = await response.json();
	      const content = result.choices[0].message.content;
	      return parseProcessedResponse(content, transcription);
	    },
	  };

	  return provider;
	}

	/** @param {string} response @param {string} originalTranscription @returns {{transcript: string, cleaned: string, summary: string, reply: string}} */
	function parseProcessedResponse(response, originalTranscription) {
	  const result = {
	    transcript: originalTranscription,
	    cleaned: "",
	    summary: "",
	    reply: "",
	  };

	  try {
	    const sections = response.split("----").map((s) => s.trim());

	    if (sections.length < 4) {
	      console.warn("Unexpected response format:", response); // TODO: Remove
	      result.cleaned = response.trim();
	      result.summary = "Error: AI response was not in the expected format";
	      result.reply = "Please try transcribing again";
	      return result;
	    }

	    result.cleaned = sections[1] || "";
	    result.summary = sections[2] || "";
	    result.reply = sections[3] || "";

	    if (!result.cleaned || !result.summary || !result.reply) {
	      console.warn("Missing sections in response:", sections); // TODO: Remove
	      result.summary =
	        result.summary ||
	        "Error: Some sections were missing from the AI response";
	      result.reply = result.reply || "Please try transcribing again";
	    }
	  } catch (error) {
	    console.error("Parsing error:", error.message); // TODO: Remove
	    result.cleaned = response.trim();
	    result.summary = "Error: Could not process AI response";
	    result.reply = "Please try transcribing again";
	  }

	  return result;
	}

	const PROVIDERS = {
	  openai: createOpenAIProvider,
	  // Future providers can be added here:
	  // claude: createClaudeProvider,
	};

	/** @param {string} type @param {Object} config @returns {Object} @throws {Error} */
	function getProvider(type, config = {}) {
	  const createProvider = PROVIDERS[type];

	  if (!createProvider) throw new Error(`Unsupported provider type: ${type}`);

	  return createProvider(config);
	}

	/** @returns {Array<string>} */
	function getSupportedProviders() {
	  return Object.keys(PROVIDERS);
	}

	/** @returns {string} */
	function getDefaultProviderType() {
	  return "openai";
	}

	const DEFAULT_SETTINGS = {
	  providerType: getDefaultProviderType(),
	  apiKey: "",
	  transcriptionModel: "whisper-1",
	  processingModel: "gpt-4o",
	  language: "auto",
	  promptTemplate: "",
	  isExtensionEnabled: true,
	};

	const supportedLanguages = [
	  { id: "auto", name: "Auto-detect" },
	  { id: "en", name: "English" },
	  { id: "es", name: "Spanish" },
	  { id: "fr", name: "French" },
	  { id: "de", name: "German" },
	  { id: "it", name: "Italian" },
	  { id: "pt", name: "Portuguese" },
	  { id: "nl", name: "Dutch" },
	  { id: "ru", name: "Russian" },
	  { id: "ja", name: "Japanese" },
	  { id: "zh", name: "Chinese" },
	  { id: "ar", name: "Arabic" },
	];

	const availableProviders = writable(
	  getSupportedProviders().map((id) => ({
	    id,
	    name: id.charAt(0).toUpperCase() + id.slice(1),
	  }))
	);

	const settings = writable({});
	const transcriptionCache = writable(new Map());

	const extensionStatus = writable({
	  isApiKeyConfigured: false,
	  isExtensionEnabled: true,
	  pendingTranscriptions: 0,
	  lastError: null,
	});

	derived(extensionStatus, ($status) => {
	  if (!$status.isApiKeyConfigured)
	    return { text: "API key not configured", type: "error" };
	  if (!$status.isExtensionEnabled)
	    return { text: "Extension disabled", type: "warning" };
	  if ($status.lastError)
	    return { text: "Error: " + $status.lastError, type: "error" };
	  if ($status.pendingTranscriptions > 0)
	    return { text: "Transcribing...", type: "pending" };

	  return { text: "Ready", type: "success" };
	});

	/** @param {Object} updates */
	function updateStatus(updates) {
	  extensionStatus.update((status) => {
	    const newStatus = { ...status };

	    if (updates.pendingTranscriptions !== undefined) {
	      if (typeof updates.pendingTranscriptions === "boolean") {
	        newStatus.pendingTranscriptions += updates.pendingTranscriptions
	          ? 1
	          : -1;
	        if (newStatus.pendingTranscriptions < 0)
	          newStatus.pendingTranscriptions = 0;
	      } else newStatus.pendingTranscriptions = updates.pendingTranscriptions;
	    }

	    if (updates.lastError !== undefined)
	      newStatus.lastError = updates.lastError;
	    if (updates.isExtensionEnabled !== undefined)
	      newStatus.isExtensionEnabled = updates.isExtensionEnabled;
	    if (updates.isApiKeyConfigured !== undefined)
	      newStatus.isApiKeyConfigured = updates.isApiKeyConfigured;

	    return newStatus;
	  });
	}

	async function initializeSettings() {
	  const transcriptions = await getTranscriptions();
	  transcriptionCache.set(transcriptions);

	  const apiKey =
	    (await get("apiKey", "local")) ||
	    (await get("apiKey", "sync"));

	  const storedSettings = await getAll("sync");

	  settings.set({
	    ...DEFAULT_SETTINGS,
	    ...storedSettings,
	    apiKey: apiKey || "",
	  });

	  updateStatus({
	    isApiKeyConfigured: !!apiKey,
	    isExtensionEnabled: storedSettings.isExtensionEnabled !== false,
	  });

	  setupSettingsPersistence();
	}

	function setupSettingsPersistence() {
	  let previousSettings = {};

	  settings.subscribe(async (currentSettings) => {
	    if (Object.keys(currentSettings).length === 0) return;

	    const hasChanged = Object.entries(currentSettings).some(
	      ([key, value]) => previousSettings[key] !== value
	    );

	    if (!hasChanged && Object.keys(previousSettings).length > 0) return;
	    previousSettings = { ...currentSettings };

	    if (currentSettings.apiKey) {
	      await set("apiKey", currentSettings.apiKey, [
	        "local",
	        "sync",
	      ]);
	      updateStatus({ isApiKeyConfigured: true });
	    }

	    for (const [key, value] of Object.entries(currentSettings))
	      if (key !== "apiKey") await set(key, value, "sync");

	    chrome.runtime.sendMessage({ action: "settingsUpdated" });
	  });

	  transcriptionCache.subscribe(async (cache) => {
	    if (cache.size > 0) {
	      const transcriptionObj = Object.fromEntries(cache);
	      await set(
	        "wa-transcriptions",
	        transcriptionObj,
	        "indexedDB"
	      );
	    }
	  });
	}

	/** @returns {Object} */
	function getSettings() {
	  return get$2(settings);
	}

	/** @param {Object} updates */
	function updateSettings(updates) {
	  settings.update((s) => ({ ...s, ...updates }));
	}

	/** @param {string} apiKey @param {string} providerType @returns {Promise<{valid: boolean, error?: string}>} */
	async function verifyApiKey$1(apiKey, providerType = null) {
	  const settings = await getSettings();
	  const type = providerType || settings.providerType || "openai";
	  const provider = getProvider(type, { apiKey });
	  return provider.verifyApiKey(apiKey);
	}

	function resetPromptTemplate(_, promptTemplate, providerType) {
		set$2(promptTemplate, defaultTemplates[get$3(providerType)]?.processing || defaultTemplates.openai.processing, true);
	}

	async function verifyApiKey(
		__1,
		apiKey,
		verificationStatus,
		isVerifying,
		providerType
	) {
		if (!get$3(apiKey)) {
			set$2(
				verificationStatus,
				{
					valid: false,
					message: "API key cannot be empty"
				},
				true
			);

			return;
		}

		set$2(isVerifying, true);
		set$2(verificationStatus, null);

		try {
			const result = await verifyApiKey$1(get$3(apiKey), get$3(providerType));

			if (result.valid) {
				set$2(
					verificationStatus,
					{
						valid: true,
						message: "API key verified successfully!"
					},
					true
				);

				updateSettings({ apiKey: get$3(apiKey) });
			} else {
				set$2(
					verificationStatus,
					{
						valid: false,
						message: result.error || "Invalid API key"
					},
					true
				);
			}
		} catch(error) {
			set$2(
				verificationStatus,
				{
					valid: false,
					message: error.message || "Error verifying API key"
				},
				true
			);
		} finally {
			set$2(isVerifying, false);
		}
	}

	function saveSettings(
		__2,
		providerType,
		transcriptionModel,
		processingModel,
		language,
		promptTemplate,
		isExtensionEnabled,
		settingsSaved
	) {
		updateSettings({
			providerType: get$3(providerType),
			transcriptionModel: get$3(transcriptionModel),
			processingModel: get$3(processingModel),
			language: get$3(language),
			promptTemplate: get$3(promptTemplate),
			isExtensionEnabled: get$3(isExtensionEnabled)
		});

		set$2(
			settingsSaved,
			{
				success: true,
				message: "Settings saved successfully!"
			},
			true
		);

		setTimeout(() => set$2(settingsSaved, null), 3000);
	}

	var root_1 = template(`<option> </option>`);
	var root_2 = template(`<p> </p>`);
	var root_3 = template(`<option> </option>`);
	var on_click = (__3, isExtensionEnabled) => set$2(isExtensionEnabled, !get$3(isExtensionEnabled));
	var root_4 = template(`<div> </div>`);

	var root = template(`<main><header><h1>WhatsApp AI Transcriber Settings</h1> <p>Configure your WhatsApp transcription settings and AI provider.</p></header> <section><h2>API Configuration</h2> <div><label for="provider">AI Provider</label> <select id="provider"></select></div> <div><label for="apiKey">API Key</label> <div><input id="apiKey" type="password" placeholder="Enter your API key"> <button type="button"> </button></div> <!> <p>Your API key is stored locally and used only for transcription requests.</p></div></section> <section><h2>Model Settings</h2> <div><label for="transcriptionModel">Transcription Model</label> <input id="transcriptionModel" type="text"></div> <div><label for="processingModel">Processing Model</label> <input id="processingModel" type="text"></div></section> <section><h2>Transcription Settings</h2> <div><label for="language">Language</label> <select id="language"></select> <p>Default language for transcription. Auto-detect will try to identify the
        language automatically.</p></div> <div><div><label for="extension-enabled">Enable Extension</label> <button type="button" role="switch" id="extension-enabled"><span class="sr-only">Use setting</span> <span aria-hidden="true"></span></button></div> <p>Turn the extension on or off without uninstalling.</p></div> <div><div><label for="promptTemplate">Prompt Template</label> <button type="button">Reset to default</button></div> <textarea id="promptTemplate" rows="8" placeholder="Enter your custom prompt template"></textarea> <p>Customize how the AI processes your transcriptions. Use double curly
        braces around "transcription" and "language" to use them as variables.</p></div></section> <div><button type="button">Save Settings</button></div> <!></main>`);

	function Options($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $availableProviders = () => store_get(availableProviders, '$availableProviders', $$stores);
		let apiKey = state("");
		let language = state("auto");
		let promptTemplate = state("");
		let isExtensionEnabled = state(true);
		let processingModel = state("gpt-4o");
		let transcriptionModel = state("whisper-1");
		let providerType = state(proxy(getDefaultProviderType()));
		let isVerifying = state(false);
		let settingsSaved = state(null);
		let verificationStatus = state(null);

		(async () => {
			await initializeSettings();

			const unsubscribe = settings.subscribe((value) => {
				if (Object.keys(value).length === 0) return;
				set$2(apiKey, value.apiKey || "", true);
				set$2(providerType, value.providerType || getDefaultProviderType(), true);
				set$2(language, value.language || "auto", true);
				set$2(transcriptionModel, value.transcriptionModel || "whisper-1", true);
				set$2(processingModel, value.processingModel || "gpt-4o", true);
				set$2(promptTemplate, value.promptTemplate || "", true);
				set$2(isExtensionEnabled, value.isExtensionEnabled !== false);
			});

			return unsubscribe;
		})();

		var main = root();

		set_class(main, 1, clsx(["p-6 max-w-3xl mx-auto font-sans"]));

		var header = child(main);

		set_class(header, 1, clsx(["mb-8"]));

		var h1 = child(header);

		set_class(h1, 1, clsx(["text-2xl font-bold text-[#128c7e] mb-2"]));

		var p = sibling(h1, 2);

		set_class(p, 1, clsx(["text-gray-600"]));

		var section = sibling(header, 2);

		set_class(section, 1, clsx(["mb-8 p-6 bg-white rounded-lg shadow-md"]));

		var h2 = child(section);

		set_class(h2, 1, clsx(["text-xl font-semibold mb-4 text-gray-800"]));

		var div = sibling(h2, 2);

		set_class(div, 1, clsx(["mb-4"]));

		var label = child(div);

		set_class(label, 1, clsx(["block text-sm font-medium text-gray-700 mb-1"]));

		var select = sibling(label, 2);

		set_class(select, 1, clsx([
			"w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#00a884] focus:border-[#00a884]"
		]));

		each(select, 5, $availableProviders, index, ($$anchor, provider) => {
			var option = root_1();
			var option_value = {};
			var text = child(option);

			template_effect(() => {
				if (option_value !== (option_value = get$3(provider).id)) {
					option.value = (option.__value = get$3(provider).id) ?? '';
				}

				set_text(text, get$3(provider).name);
			});

			append($$anchor, option);
		});

		var div_1 = sibling(div, 2);

		set_class(div_1, 1, clsx(["mb-4"]));

		var label_1 = child(div_1);

		set_class(label_1, 1, clsx(["block text-sm font-medium text-gray-700 mb-1"]));

		var div_2 = sibling(label_1, 2);

		set_class(div_2, 1, clsx(["flex"]));

		var input = child(div_2);

		set_class(input, 1, clsx([
			"flex-1 p-2 border border-gray-300 rounded-l-md shadow-sm focus:ring-[#00a884] focus:border-[#00a884]"
		]));

		var button = sibling(input, 2);

		button.__click = [
			verifyApiKey,
			apiKey,
			verificationStatus,
			isVerifying,
			providerType
		];

		set_class(button, 1, clsx([
			"bg-[#00a884] text-white px-4 py-2 rounded-r-md hover:bg-[#008f72] focus:outline-none focus:ring-2 focus:ring-[#00a884] focus:ring-offset-2 disabled:opacity-50"
		]));

		var text_1 = child(button);

		var node = sibling(div_2, 2);

		{
			var consequent = ($$anchor) => {
				var p_1 = root_2();
				var text_2 = child(p_1);

				template_effect(() => {
					set_class(p_1, 1, clsx([
						"mt-2 text-sm break-words max-w-full overflow-hidden",
						get$3(verificationStatus).valid ? "text-green-600" : "text-red-600"
					]));

					set_text(text_2, get$3(verificationStatus).message);
				});

				append($$anchor, p_1);
			};

			if_block(node, ($$render) => {
				if (get$3(verificationStatus)) $$render(consequent);
			});
		}

		var p_2 = sibling(node, 2);

		set_class(p_2, 1, clsx(["mt-2 text-xs text-gray-500"]));

		var section_1 = sibling(section, 2);

		set_class(section_1, 1, clsx(["mb-8 p-6 bg-white rounded-lg shadow-md"]));

		var h2_1 = child(section_1);

		set_class(h2_1, 1, clsx(["text-xl font-semibold mb-4 text-gray-800"]));

		var div_3 = sibling(h2_1, 2);

		set_class(div_3, 1, clsx(["mb-4"]));

		var label_2 = child(div_3);

		set_class(label_2, 1, clsx(["block text-sm font-medium text-gray-700 mb-1"]));

		var input_1 = sibling(label_2, 2);

		set_class(input_1, 1, clsx([
			"w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#00a884] focus:border-[#00a884]"
		]));

		var div_4 = sibling(div_3, 2);

		set_class(div_4, 1, clsx(["mb-4"]));

		var label_3 = child(div_4);

		set_class(label_3, 1, clsx(["block text-sm font-medium text-gray-700 mb-1"]));

		var input_2 = sibling(label_3, 2);

		set_class(input_2, 1, clsx([
			"w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#00a884] focus:border-[#00a884]"
		]));

		var section_2 = sibling(section_1, 2);

		set_class(section_2, 1, clsx(["mb-8 p-6 bg-white rounded-lg shadow-md"]));

		var h2_2 = child(section_2);

		set_class(h2_2, 1, clsx(["text-xl font-semibold mb-4 text-gray-800"]));

		var div_5 = sibling(h2_2, 2);

		set_class(div_5, 1, clsx(["mb-4"]));

		var label_4 = child(div_5);

		set_class(label_4, 1, clsx(["block text-sm font-medium text-gray-700 mb-1"]));

		var select_1 = sibling(label_4, 2);

		set_class(select_1, 1, clsx([
			"w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#00a884] focus:border-[#00a884]"
		]));

		each(select_1, 21, () => supportedLanguages, index, ($$anchor, lang) => {
			var option_1 = root_3();
			var option_1_value = {};
			var text_3 = child(option_1);

			template_effect(() => {
				if (option_1_value !== (option_1_value = get$3(lang).id)) {
					option_1.value = (option_1.__value = get$3(lang).id) ?? '';
				}

				set_text(text_3, get$3(lang).name);
			});

			append($$anchor, option_1);
		});

		var p_3 = sibling(select_1, 2);

		set_class(p_3, 1, clsx(["mt-1 text-xs text-gray-500"]));

		var div_6 = sibling(div_5, 2);

		set_class(div_6, 1, clsx(["mb-4"]));

		var div_7 = child(div_6);

		set_class(div_7, 1, clsx(["flex items-center justify-between"]));

		var label_5 = child(div_7);

		set_class(label_5, 1, clsx(["text-sm font-medium text-gray-700"]));

		var button_1 = sibling(label_5, 2);

		button_1.__click = [on_click, isExtensionEnabled];

		var span = sibling(child(button_1), 2);

		var p_4 = sibling(div_7, 2);

		set_class(p_4, 1, clsx(["mt-1 text-xs text-gray-500"]));

		var div_8 = sibling(div_6, 2);

		set_class(div_8, 1, clsx(["mb-4"]));

		var div_9 = child(div_8);

		set_class(div_9, 1, clsx(["flex justify-between items-center mb-1"]));

		var label_6 = child(div_9);

		set_class(label_6, 1, clsx(["block text-sm font-medium text-gray-700"]));

		var button_2 = sibling(label_6, 2);

		button_2.__click = [
			resetPromptTemplate,
			promptTemplate,
			providerType
		];

		set_class(button_2, 1, clsx([
			"text-xs text-[#00a884] hover:text-[#008f72] underline"
		]));

		var textarea = sibling(div_9, 2);

		set_class(textarea, 1, clsx([
			"w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#00a884] focus:border-[#00a884] font-mono text-sm"
		]));

		var p_5 = sibling(textarea, 2);

		set_class(p_5, 1, clsx(["mt-1 text-xs text-gray-500"]));

		var div_10 = sibling(section_2, 2);

		set_class(div_10, 1, clsx(["flex justify-end"]));

		var button_3 = child(div_10);

		button_3.__click = [
			saveSettings,
			providerType,
			transcriptionModel,
			processingModel,
			language,
			promptTemplate,
			isExtensionEnabled,
			settingsSaved
		];

		set_class(button_3, 1, clsx([
			"bg-[#00a884] text-white px-6 py-2 rounded-md hover:bg-[#008f72] focus:outline-none focus:ring-2 focus:ring-[#00a884] focus:ring-offset-2"
		]));

		var node_1 = sibling(div_10, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_11 = root_4();

				set_class(div_11, 1, clsx([
					"mt-4 p-3 bg-green-100 text-green-800 rounded-md"
				]));

				var text_4 = child(div_11);
				template_effect(() => set_text(text_4, get$3(settingsSaved).message));
				append($$anchor, div_11);
			};

			if_block(node_1, ($$render) => {
				if (get$3(settingsSaved)) $$render(consequent_1);
			});
		}

		template_effect(() => {
			button.disabled = get$3(isVerifying);
			set_text(text_1, get$3(isVerifying) ? "Verifying..." : "Verify");
			set_attribute(button_1, 'aria-checked', get$3(isExtensionEnabled));

			set_class(button_1, 1, clsx([
				"relative inline-flex flex-shrink-0 h-6 w-11 border-2 items-center border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#00a884]",
				get$3(isExtensionEnabled) ? "bg-[#00a884]" : "bg-gray-200"
			]));

			set_class(span, 1, clsx([
				"pointer-events-none inline-block h-5 w-5 rounded-full bg-white shadow transform ring-0 transition ease-in-out duration-200",
				get$3(isExtensionEnabled) ? "translate-x-[13px]" : "-translate-x-[9px]"
			]));
		});

		bind_select_value(select, () => get$3(providerType), ($$value) => set$2(providerType, $$value));
		bind_value(input, () => get$3(apiKey), ($$value) => set$2(apiKey, $$value));
		bind_value(input_1, () => get$3(transcriptionModel), ($$value) => set$2(transcriptionModel, $$value));
		bind_value(input_2, () => get$3(processingModel), ($$value) => set$2(processingModel, $$value));
		bind_select_value(select_1, () => get$3(language), ($$value) => set$2(language, $$value));
		bind_value(textarea, () => get$3(promptTemplate), ($$value) => set$2(promptTemplate, $$value));
		append($$anchor, main);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	const app = mount(Options, {
	  target: document.getElementById("whatsapp-transcriber-app"),
	});

	return app;

})();
//# sourceMappingURL=options.js.map
